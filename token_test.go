package nzcpv_test

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"errors"
	"math/big"
	"testing"

	"github.com/echojc/nzcpv"
)

func TestValidToken(t *testing.T) {
	qr := "NZCP:/1/2KCEVIQEIVVWK6JNGEASNICZAEP2KALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRUYMBTIFAIGTUKBAAUYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWISTBMNVWUZTBNVUWY6KOMFWWKZ2TOBQXE4TPO5RWI33CNIYTSNRQFUYDILJRGYDVAYFE6VGU4MCDGK7DHLLYWHVPUS2YIDJOA6Y524TD3AZRM263WTY2BE4DPKIF27WKF3UDNNVSVWRDYIYVJ65IRJJJ6Z25M2DO4YZLBHWFQGVQR5ZLIWEQJOZTS3IQ7JTNCFDX"

	tkn, err := nzcpv.NewToken(qr)
	if err != nil {
		t.Errorf("Valid token did not unmarshal: %v", err)
		t.FailNow()
	}

	tv := newTestValidator(t)
	if errs := tv.ValidateToken(tkn); errs != nil {
		t.Errorf("Expected token to be valid, got: %v", errs)
		t.FailNow()
	}
}

var invalidTokens = []struct {
	desc     string
	expected []error
	qr       string
}{
	{
		desc:     "bad signature 1 (signed by different key)",
		expected: []error{nzcpv.ErrBadSignature},
		qr:       "NZCP:/1/2KCEVIQEIVVWK6JNGEASNICZAEP2KALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRUYMBTIFAIGTUKBAAUYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWISTBMNVWUZTBNVUWY6KOMFWWKZ2TOBQXE4TPO5RWI33CNIYTSNRQFUYDILJRGYDVAY73U6TCQ3KF5KFML5LRCS5D3PCYIB2D3EOIIZRPXPUA2OR3NIYCBMGYRZUMBNBDMIA5BUOZKVOMSVFS246AMU7ADZXWBYP7N4QSKNQ4TETIF4VIRGLHOXWYMR4HGQ7KYHHU",
	},
	{
		desc:     "unknown public key",
		expected: []error{nzcpv.ErrUnknownPublicKey},
		qr:       "NZCP:/1/2KCEVIQEIVVWK6JNGIASNICZAEP2KALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRUYMBTIFAIGTUKBAAUYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWISTBMNVWUZTBNVUWY6KOMFWWKZ2TOBQXE4TPO5RWI33CNIYTSNRQFUYDILJRGYDVBMP3LEDMB4CLBS2I7IOYJZW46U2YIBCSOFZMQADVQGM3JKJBLCY7ATASDTUYWIP4RX3SH3IFBJ3QWPQ7FJE6RNT5MU3JHCCGKJISOLIMY3OWH5H5JFUEZKBF27OMB37H5AHF",
	},
	{
		desc:     "bad signature 2 (modified signature)",
		expected: []error{nzcpv.ErrBadSignature},
		qr:       "NZCP:/1/2KCEVIQEIVVWK6JNGEASNICZAEP2KALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRUYMBTIFAIGTUKBAAUYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWISTBMNVWUZTBNVUWY6KOMFWWKZ2TOBQXE4TPO5RWI33CNIYTSNRQFUYDILJRGYDVAYFE6VGU4MCDGK7DHLLYWHVPUS2YIAAAAAAAAAAAAAAAAC63WTY2BE4DPKIF27WKF3UDNNVSVWRDYIYVJ65IRJJJ6Z25M2DO4YZLBHWFQGVQR5ZLIWEQJOZTS3IQ7JTNCFDX",
	},
	{
		desc:     "bad signature 3 (modified payload)",
		expected: []error{nzcpv.ErrBadSignature},
		qr:       "NZCP:/1/2KCEVIQEIVVWK6JNGEASNICZAEOKKALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRUYMBTIFAIGTUKBAAUYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWKU3UMV3GK2TGMFWWS3DZJZQW2ZLDIRXWKY3EN5RGUMJZGYYC2MBUFUYTMB2QMCSPKTKOGBBTFPRTVV4LD2X2JNMEAAAAAAAAAAAAAAAABPN3J4NASOBXVEC5P3FC52BWW2ZK3IR4EMKU7OUIUUU7M5OWNBXOMMVQT3CYDKYI64VULCIEXMZZNUIPUZWRCR3Q",
	},
	{
		desc:     "expired token",
		expected: []error{nzcpv.ErrTokenExpired},
		qr:       "NZCP:/1/2KCEVIQEIVVWK6JNGEASNICZAEP2KALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRUX5AM2FQIGTBPBPYWYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWISTBMNVWUZTBNVUWY6KOMFWWKZ2TOBQXE4TPO5RWI33CNIYTSNRQFUYDILJRGYDVA56TNJCCUN2NVK5NGAYOZ6VIWACYIBM3QXW7SLCMD2WTJ3GSEI5JH7RXAEURGATOHAHXC2O6BEJKBSVI25ICTBR5SFYUDSVLB2F6SJ63LWJ6Z3FWNHOXF6A2QLJNUFRQNTRU",
	},
	{
		desc:     "inactive token",
		expected: []error{nzcpv.ErrTokenNotActive},
		qr:       "NZCP:/1/2KCEVIQEIVVWK6JNGEASNICZAEP2KALYDZSGSZB2O5SWEOTOPJRXALTDN53GSZBRHEXGQZLBNR2GQLTOPICRU2XI5UFQIGTMZIQIWYTWMOSGQQDDN5XHIZLYOSBHQJTIOR2HA4Z2F4XXO53XFZ3TGLTPOJTS6MRQGE4C6Y3SMVSGK3TUNFQWY4ZPOYYXQKTIOR2HA4Z2F4XW46TDOAXGG33WNFSDCOJONBSWC3DUNAXG46RPMNXW45DFPB2HGL3WGFTXMZLSONUW63TFGEXDALRQMR2HS4DFQJ2FMZLSNFTGSYLCNRSUG4TFMRSW45DJMFWG6UDVMJWGSY2DN53GSZCQMFZXG4LDOJSWIZLOORUWC3CTOVRGUZLDOSRWSZ3JOZSW4TTBNVSWISTBMNVWUZTBNVUWY6KOMFWWKZ2TOBQXE4TPO5RWI33CNIYTSNRQFUYDILJRGYDVA27NR3GFF4CCGWF66QGMJSJIF3KYID3KTKCBUOIKIC6VZ3SEGTGM3N2JTWKGDBAPLSG76Q3MXIDJRMNLETOKAUTSBOPVQEQAX25MF77RV6QVTTSCV2ZY2VMN7FATRGO3JATR",
	},
}

func TestInvalidTokens(t *testing.T) {
	tv := newTestValidator(t)
	for _, tc := range invalidTokens {
		t.Run(tc.desc, func(t *testing.T) {
			tkn, err := nzcpv.NewToken(tc.qr)
			if err != nil {
				t.Errorf("Could not unmarshal clean QR (got: %v)", err)
				t.FailNow()
			}

			if errs := tv.ValidateToken(tkn); !checkErrors(tc.expected, errs) {
				t.Errorf("Expected %v, got %v", tc.expected, errs)
				t.FailNow()
			}
		})
	}
}

var corruptQRs = []struct {
	desc     string
	expected error
	qr       string
}{
	{
		desc:     "empty",
		expected: nzcpv.ErrMissingNZCPPrefix,
		qr:       "",
	},
	{
		desc:     "missing prefix",
		expected: nzcpv.ErrMissingNZCPPrefix,
		qr:       "boop/1/data",
	},
	{
		desc:     "missing version",
		expected: nzcpv.ErrBadNZCPVersion,
		qr:       "NZCP://data",
	},
	{
		desc:     "invalid version",
		expected: nzcpv.ErrBadNZCPVersion,
		qr:       "NZCP:/999/data",
	},
	{
		desc:     "bad data",
		expected: nzcpv.ErrBadNZCPPayload,
		qr:       "NZCP:/1/$%^&*",
	},
	{
		desc:     "incomplete data",
		expected: nzcpv.ErrInvalidTokenFormat,
		qr:       "NZCP:/1/2KCEV",
	},
}

func TestCorruptQRs(t *testing.T) {
	for _, tc := range corruptQRs {
		t.Run(tc.desc, func(t *testing.T) {
			_, err := nzcpv.NewToken(tc.qr)
			if !errors.Is(err, tc.expected) {
				t.Errorf("Expected %v, got %v", tc.expected, err)
			}
		})
	}
}

var testKey1 = &ecdsa.PublicKey{
	Curve: elliptic.P256(),
	X: big.NewInt(0).SetBytes([]byte{
		0xcd, 0x14, 0x7e, 0x5c, 0x6b, 0x02, 0xa7, 0x5d,
		0x95, 0xbd, 0xb8, 0x2e, 0x8b, 0x80, 0xc3, 0xe8,
		0xee, 0x9c, 0xaa, 0x68, 0x5f, 0x3e, 0xe5, 0xcc,
		0x86, 0x2d, 0x4e, 0xc4, 0xf9, 0x7c, 0xef, 0xad,
	}),
	Y: big.NewInt(0).SetBytes([]byte{
		0x22, 0xfe, 0x52, 0x53, 0xa1, 0x6e, 0x5b, 0xe4,
		0xd1, 0x62, 0x1e, 0x7f, 0x18, 0xea, 0xc9, 0x95,
		0xc5, 0x7f, 0x82, 0x91, 0x7f, 0x1a, 0x91, 0x50,
		0x84, 0x23, 0x83, 0xf0, 0xb4, 0xa4, 0xdd, 0x3d,
	}),
}

func newTestValidator(t *testing.T) *nzcpv.Validator {
	// add test issuer/key from specification
	tv := nzcpv.NewValidator()
	tv.RegisterIssuer("did:web:nzcp.covid19.health.nz")
	err := tv.RegisterPublicKey("did:web:nzcp.covid19.health.nz#key-1", testKey1)
	if err != nil {
		t.Errorf("Could not register test keys for validator: %v\n", err)
		t.FailNow()
	}
	return tv
}

func checkErrors(expected, actual []error) bool {
	if len(expected) != len(actual) {
		return false
	}

	remaining := make([]error, len(actual))
	copy(remaining, actual)
	for _, target := range expected {
		for i, err := range remaining {
			if errors.Is(err, target) {
				remaining = append(remaining[:i], remaining[i+1:]...)
				break
			}
		}
	}
	return len(remaining) == 0
}
